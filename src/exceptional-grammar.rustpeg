use ast::{Expression, Statement, Literal};
use num::BigInt;
use num::rational::{Ratio};

#[pub]
statements -> Vec<Statement>
  = statement ** __

statement -> Statement
  = assignStatement
  / callStatement
  / raiseStatement

assignStatement -> Statement
  = let ident:identifier "=" __ exp:expression {
      Statement::Assign(true, ident, Box::new(exp))
    }

  / ident:identifier "=" __ exp:expression {
      Statement::Assign(false, ident, Box::new(exp))
    }

raiseStatement -> Statement
  = raise lparen args:functionArguments rparen {
      Statement::Raise(args)
    }

callStatement -> Statement
  = ident:identifier lparen args:functionArguments rparen {
      Statement::Call(ident, args)
    }

functionArguments -> Vec<Expression>
  = args:(expression ** comma) {
      args
    }

#[pub]
expression -> Expression
  = functionDefinition
  / addition

addition -> Expression
  = left:multiplication op:addition_op right:addition {
      Expression::BinOp(op, Box::new(left), Box::new(right))
    }
  / multiplication

addition_op -> String
  = op:$([+-]) __ { op.to_owned() }

multiplication -> Expression
  = left:primary op:multiplication_op right:multiplication {
      Expression::BinOp(op, Box::new(left), Box::new(right))
    }
  / primary

multiplication_op -> String
  = op:$([*/]) __ { op.to_owned() }

primary -> Expression
  = val:literal { Expression::Literal(val) }
  / ident:identifier { Expression::Identifier(ident) }
  /* / lparen exp:expression rparen { exp } */

identifier -> String
  = !keywords ident:$([a-zA-Z] [a-zA-Z0-9_]*) __ { ident.to_owned() }

#[pub]
literal -> Literal
  = number
  / charString
  / boolean
  / map

number -> Literal
  = digits:digits __ {
      Literal::Number(Ratio::from_integer(BigInt::parse_bytes(digits.as_bytes(), 10).unwrap()))
    }

digits -> String
  /* = c:$([0-9]+) "." d:$([0-9]+) { c.parse().unwrap() } */
  = c:$([0-9]+) { c.parse().unwrap() }

charString -> Literal
  = string:string __ { Literal::CharString(string) }

string -> String
  = '"' s:doubleQuotedCharacter* '"' { s.into_iter().collect() }

doubleQuotedCharacter -> char
  = !('"' / "\\" / eolChar) c:$. { c.chars().next().unwrap() }

boolean -> Literal
  = b:"false" __ { Literal::Boolean(false) }
  / b:"true" __ { Literal::Boolean(true) }

functionDefinition -> Expression
  = "def" lparen args:functionArgumentList rparen block:block {
      Expression::Literal(
        Literal::Fn(Box::new(args), Box::new(block))
      )
    }

functionArgumentList -> Vec<String>
  = identifier ** comma

comma
  = "," __

block -> Vec<Statement>
  = do statements:statements end { statements }

map -> Literal
  = lbracket pairs:keyPairList rbracket {
      Literal::Map(pairs)
    }

keyPairList -> Vec<(Expression, Expression)>
  = pairs:(key:expression fatArrow value:expression { (key, value) } )* {
      pairs
    }
__
  = [ \n]*
  / comment

comment
  = "#" (!eolChar .)*

keywords
  = let
  / "def"
  / "do"
  / end
  / raise

let
  = "let" __

do
  = "do" __

end
  = "end" __

raise
  = "raise"

lparen
  = "(" __

rparen
  = __ ")" __

lbracket
  = __ "{" __

rbracket
  = __ "}" __

fatArrow
  = __ "=>" __

eolChar
  = [\n\r\u{2028}\u{2029}]
